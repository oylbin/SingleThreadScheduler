一个C++的线程绑定调度器，可以用来在特定线程执行任务。

1. 任务线程是一个单独的线程。它负责执行任务队列中的任务，确保任务按照调度的顺序执行。
2. 单一线程可以保证不会有并发问题。
3. 任务线程提供添加任务和删除任务的接口。




你提供的示例，都是把一个闭包函数作为task。

假设一个task T在文件A的函数B中调度（添加到任务队列），它真正执行时，是在任务线程的 thread loop中。
如果task T在出现异常，此时它的堆栈信息并不包括函数B的堆栈信息。所以我比较难定位这个task T究竟是在何处被调度而引发的异常。

我有个想法是，把task做一层封装。这个task对象的构造函数，接受一个 Callable对象，以及 `__file__` 和 `__line__` 参数，把它们作为task对象的成员变量记录下来。
这样当task执行时，是执行它的 Callable member，如果抛出异常时，我可以根据它的 file 和 line 信息，定位到是哪一行代码调度了这个task，从而找到异常来源。

你觉得这个思路怎样？你是否有更好的建议？